import os
import colorama
import time
import signal
import sys
# 一些常量
key_binding = {
    "Up": ["j", "w", "^"],
    "Down": ["k", "s", "v"],
    "Left": ["h", "a", "<"],
    "Right": ["l", "d", ">"],
    "Other": ["f", "e", "q"]
    # "f" --> flag
    # "e" --> reveal
    # "q" --> quit
}
BG = colorama.Back.GREEN
BB = colorama.Back.BLUE
BY = colorama.Back.YELLOW
RES = colorama.Style.RESET_ALL
Width = 3
board_line = 3
element = {"Boom": "*", "Unknow": "?", "Flag": "^", "Flat": " "}
num_key = [str(x) for x in range(10)]  ### 数字键

move = lambda line, col=1: cout(f"\033[{line};{col}H")  # 绝对移动
cout = lambda *printed: print(*printed, end="", sep="")  # 改变默认参数的print
cline = lambda: (cout("\033[2K"))  # 清行
cls = lambda: (cout("\033[2J\033[H"))  # 清屏
hide_cursor = lambda: cout("\033[?25l")
show_cursor = lambda: cout("\033[?25h")
# 下面四个(相对坐标移动)好像都没用到，用的绝对坐标
up = lambda n: cout(f"\033[{n}A")
down = lambda n: cout(f"\033[{n}B")
right = lambda n: cout(f"\033[{Width * n}C")
left = lambda n: cout(f"\033[{Width * n}D")
# 判断当前shell(os.system用到的命令区别, bash touch, cmd/pwsh ni, etc)
shell_env = os.environ.get('SHELL')
if shell_env is None:  # Windows systems often don't have SHELL environment variable
    shell_mode = 1
else:
    shell = shell_env.decode().strip().split() if isinstance(
        shell_env, bytes) else shell_env.strip().split()
    if "powershell" in shell or "cmd" in shell:
        shell_mode = 1
    else:
        shell_mode = 0
#### ai 改了下windows shell环境判定(linux可以直接用原来的, win就有问题)


### 利用 ANSI 转义序列实现清屏移动光标等
def init_program():
    """
    初始化程序
    """
    hide_cursor()
    try:
        os.system("")  # ANSI 转义序列支持
    except Exception:
        print("Failed to enable ANSI")
        exit()

    colorama.init()


# getch实现无缓冲输入(win是c/c++同款，直接调用msvcrt动态链接库，类unix是ai写的)
def make_getch():
    """
    高阶函数封装判断平台过程
    """
    if os.name == "nt":  
        """
        Windows NT内核，其余基本都是类unix(posix, 是一个标准而不是内核名称)，除了ChromeOS之类的怪胎
        类unix包括unix, linux, 各种BSD之类的内核
        pthon3的os库里name的判定只有nt和posix两种, python2有mac之类的, mac也是基于unix
        sys.platform可以判定具体平台,
        因为只有win一个独狼不支持termios库和posix里的的一些东西，这里直接用os.name
        msvctr的getch性能应该更好? 毕竟直接调用visual c++(这玩意好像没开源, 其他系统没有)
        """
        from msvcrt import getch

        def win_get() -> str:
            return getch().decode()  # decode解码将byte对象转字符串

        return win_get
    else:
        import termios
        from tty import setraw
        from sys import stdin

        def unix_get() -> str:  # 看不懂思密达, generated by doubao
            fd = stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            try:
                setraw(stdin.fileno())
                ch = stdin.read(1)
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
            return ch

        return unix_get


# getch = make_getch() # make_getch有bug，ai在demo里重新了搞了份, 加了方向键的按键映射
from demo import getch


def print_all(Line, All):
    """
    只在开始运行打印一次，后面通过光标移动更改
    """
    cls()
    move(board_line)
    cout("  +" + "-" * (Line * Width + Width - 1), "+\n")
    for i in All[1:]:
        cout("  | ")
        for j in i[1:]:
            cout(" ", j, " ")
        cout(" |\n")
    cout("  +" + "-" * (Line * Width + Width - 1), "+")


def move_info(line: int, col: int) -> tuple:
    # ":*"和"->*"都是类型注释
    """
    将行列号转终端光标坐标
    """
    global board_line
    return line + board_line, col * Width


def generate_boom(All: list, num: int) -> list:
    """
    生成炸弹
    """
    Origin = list(All)
    from random import randint
    Line = get_line(Origin)

    rand_line = (lambda Line: (lambda: randint(1, Line)))(Line)
    # 高阶函数封装参数Line，配合lambda定义调用放一起实现可读性极差(笑)
    temp = set()
    while num > 0:
        pos = rand_line(), rand_line()
        if pos not in temp:
            temp.add(pos)
            num -= 1
    for i, j in list(temp):
        Origin[i][j] = element["Boom"]
    Origin[0] = True  # 用来标记是否成功生成炸弹
    return Origin


def get_line(item_set):
    """
    获取棋盘的边长
    """
    return len(item_set) - 1


def is_boom(pos, Origin):
    if Origin[pos[0]][pos[1]] == element["Boom"]:
        return True
    return False


def get_item(item_set, pos):
    """
    获得对应元素
    """
    return item_set[pos[0]][pos[1]]


def cal_count(Count, Origin):
    """
    计算每个位置炸弹数量
    """
    Line = get_line(Origin)
    for i in range(1, Line + 1):
        for j in range(1, Line + 1):
            all_edge = {(i - 1, j - 1), (i - 1, j), (i - 1, j + 1),
                        (i + 1, j - 1), (i + 1, j), (i + 1, j + 1), (i, j - 1),
                        (i, j + 1)}
            positions = [(r, c) for r, c in all_edge
                         if 1 <= r <= Line and 1 <= c <= Line]
            Count[i][j] = sum(1 for pos in positions if is_boom(pos, Origin))

    return Count


def show_line(line, Line):
    """
    显示相对行号
    """
    move(board_line + line)
    cout(BG, f"{abs(line):^2}", BB)
    for temp_line in range(1, Line + 1):
        if temp_line != line:
            move(board_line + temp_line, 1)
            relative = temp_line - line
            cout(f"{abs(relative):^2}")
        else:
            cout(BY)
    cout(RES)


def show_col(col, Line):
    """
    相对列号
    """
    _, term_col = move_info(1, col)  # 用不到的变量用下划线

    move(board_line - 1, term_col + 1)
    cout(colorama.Back.GREEN, f"{col:^3}", BB)
    for temp_col in range(1, Line + 1):
        if temp_col != col:
            _, term_col = move_info(1, temp_col)
            move(board_line - 1, term_col + 1)
            relative = temp_col - col
            cout(f"{abs(relative):^3}")
        else:
            cout(BY)
    cout(RES)


def show_relevant(line, col, Line, All):
    """
    显示相对行列号，高亮当前元素
    """
    show_line(line, Line)
    show_col(col, Line)
    shell_line, shell_col = move_info(line, col)
    move(shell_line, shell_col - 1)
    cout(BG, " ", get_item(All, (line, col)), " ", RES)


def click_item(line, col, Line, All, Origin, is_flaged, Count, is_revealed):
    """
    实现reveal动作, (click指原版扫雷点鼠标, 这里实际是摁键盘)
    """
    if is_flaged[line][col] or is_revealed[line][col]:
        return False, All, is_flaged, is_revealed
    if Origin[line][col] == element["Boom"]:
        is_revealed[line][col] = True
        return True, All, is_flaged, is_revealed

    def inner(l, c):
        """
        递归大法好，翻牌子
        """
        nonlocal All, is_flaged, is_revealed
        # nonlocal关键字调用父帧变量
        # 不加也可以调用，但是如果进行赋值操作会变成局部变量，不会影响父帧中同变量
        # global同理，不过调用的是全局帧的变量
        if l < 1 or l > Line or c < 1 or c > Line or is_revealed[l][c]:
            # 越界或者已经判定过直接pass
            return

        if Origin[l][c] == element["Boom"]:
            # 炸弹pass
            return

        is_revealed[l][c] = True
        is_flaged[l][c] = False

        if Count[l][c] > 0:
            All[l][c] = str(Count[l][c])
            return
        else:  # 递归主体，其他为base case(基例/基线)
            All[l][c] = element["Flat"]
            for tl in [-1, 0, 1]:
                for tc in [-1, 0, 1]:
                    if tl == 0 and tc == 0:
                        continue
                    inner(l + tl, c + tc)

    inner(line, col)
    return False, All, is_flaged, is_revealed


def refresh_pos(pos, All, is_current=False):
    """
    重新打印某行，没用到，最终直接重新打印某个字符了
    """
    move(move_info(pos))
    left(1)
    if is_current:
        cout(BG)
    cout(" ", All[pos[0]][pos[1]], " ")
    if is_current:
        cout(RES)


def print_cursor(pos, All):
    """
    没用到，忘了写这玩意是干嘛的了，留着先，这个函数还没完成
    """
    move(move_info(*pos))
    left


def clear_bg(icon, pre_pos):
    """
    规则为当前光标所在格子高亮
    这个函数的作用是清除高亮效果(重打印嘛)
    高亮的部分放在show_relvant里了
    """
    term_line, term_col = move_info(pre_pos[0], pre_pos[1])
    move(term_line, term_col - 1)
    cout(BG, " ", icon, " ", RES)


def print_message(Line, message, pre_pos, error=False):
    """
    打印信息，包括报错和按键
    """
    move(board_line + Line + (5 if error else 6))
    cline()
    cout(message)
    move(*pre_pos)


def clear_error(Line, pre_pos):
    """
    清除错误信息打印
    """
    move(board_line + Line + 6)
    cline()
    move(*pre_pos)


def get_key(Line, cursor_pos):
    """
    获取按键和数字键
    """
    current_key = None
    num_buffer = []
    is_ok = False
    while not is_ok:
        try:
            clear_error(Line, cursor_pos)
            if num_buffer:
                cline()
                print_message(Line, *num_buffer, cursor_pos)
            current_key = getch()
            if current_key in num_key:
                num_buffer.append(current_key)
            elif not any(current_key in keys for keys in key_binding.values()):
                print_message(Line, f"key {current_key} is invalid!",
                              cursor_pos, True)
            else:
                is_ok = True
        except Exception as e:
            print_message(Line, f"Error: {str(e)}", cursor_pos, True)
    num_buffer = [int(i) for i in num_buffer]  # getch().decode()是字符串
    if num_buffer == []:
        total = 1
    else:
        total = 0
        for i in num_buffer:
            total = total * 10 + i
    return total, current_key


def move_cursor_info(motion, cursor_pos, total, Line):
    """
    返回移动后的坐标，用max和min简化了，之前的又臭又长
    """
    if motion == "Up":
        return [max(1, cursor_pos[0] - total), cursor_pos[1]]
    elif motion == "Down":
        return [min(Line, cursor_pos[0] + total), cursor_pos[1]]
    elif motion == "Left":
        return [cursor_pos[0], max(1, cursor_pos[1] - total)]
    elif motion == "Right":
        return [cursor_pos[0], min(Line, cursor_pos[1] + total)]


def print_boom(pos):
    """
    Boom 的时候红色高亮炸弹
    """
    move(*move_info(pos))
    cout(colorama.Back.RED, " ", element["Boom"], " ", RES)


def count_remain(All, boom_count):
    """
    判定是否win game用的
    """
    total = get_line(All)**2
    count = 0
    for i in All[1:]:
        for j in i[1:]:
            if j == element["Flat"]:
                count += 1
    return (total - count) == boom_count


def run(Line=10,
        boom_count=None,
        All=None,
        Origin=None,
        is_flaged=None,
        is_revealed=None,
        total_time=0):
    init_program()

    #判断是否给定数据，并生成缺失数据

    if not boom_count:
        boom_count = 2 * Line
    boom_count = min(boom_count, Line**2 // 4)  # 限制下炸弹数量
    if not Origin:
        All = [[False]] + [[element["Unknow"] for _ in range(Line + 1)]
                           for _ in range(Line)]
        Origin = generate_boom(All, boom_count)
    else:
        Line = get_line(All)
    if not is_flaged:
        is_flaged = [[False] * (Line + 1) for _ in range(Line + 1)]
    if not is_revealed:
        is_revealed = [[False] * (Line + 1) for _ in range(Line + 1)]
    Count = [[0 for _ in range(Line + 1)] for _ in range(Line + 1)]

    #######################

    print_all(Line, All)
    pos = [Line // 2 if Line > 1 else 1, Line // 2 if Line > 1 else 1]
    show_relevant(*pos, Line, All)

    Count = cal_count(Count, Origin)

    # mainloop --> 又臭又长 #

    while True:
        total, current_key = get_key(Line, pos)

        if current_key in key_binding["Other"]:  # flag or reveal

            print_message(Line, "", pos)  # 清除信息，flag与reveal行为不能与数字组合
            if current_key == key_binding["Other"][0]:
                is_flaged[pos[0]][pos[1]] = not get_item(is_flaged, pos)
                if get_item(is_flaged, pos):
                    All[pos[0]][pos[1]] = element["Flag"]
                else:
                    All[pos[0]][pos[1]] = element["Unknow"]
                show_relevant(*pos, Line, All)

            else:

                is_boom_result, All, is_flaged, is_revealed = click_item(
                    *pos, Line, All, Origin, is_flaged, Count, is_revealed)
                ##########
                if is_boom_result:
                    print_boom(pos)
                    print_message(Line, "BOOM!", pos)
                    show_relevant(*pos, Line, All)
                    break
                if count_remain(All, boom_count):
                    print_message(Line, "WIN!", pos)
                    show_relevant(*pos, Line, All)
                    break
                ##########
                show_relevant(*pos, Line, All)
        else:  # move cursocr
            for direction, keys in key_binding.items():
                if current_key in keys:
                    motion = direction
                    break
            clear_bg(get_item(All, pos), pos)
            pos = move_cursor_info(motion, pos, total, Line)
            show_relevant(*pos, Line, All)

    #

    move(1)
    down(Line + board_line + 3)
    show_cursor()


#############################
def start():

    Line = 10

    def signal_handler():
        """
        劫持信号
        """
        move(1)
        down(Line + board_line + 3)
        print("Exit game")
        show_cursor()
        sys.exit(0)

    if os.name == "nt":
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
    else:
        signal.signal(signal.SIGTSTP, signal_handler)
        signal.signal(signal.SIGQUIT, signal_handler)
    run(Line)


# start()
#############################

# Line = 10
# All = [[False]] + [[element["Unknow"] for _ in range(Line + 1)]
#                    for _ in range(Line)]
