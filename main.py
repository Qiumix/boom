import os
import colorama
import time
# 一些常量
key_binding = {
    "Up": ["j", "w"],
    "Down": ["k", "s"],
    "Left": ["h", "a"],
    "Right": ["l", "d"],
    "Other": ["q", "e"]
    # "q" -> flag
    # "e" -> reveal
}
BG = colorama.Back.GREEN
BB = colorama.Back.BLUE
BY = colorama.Back.YELLOW
RES = colorama.Style.RESET_ALL
Width = 3
board_line = 3
element = {"Boom": "*", "Unknow": "?", "Flag": "^", "Flat": " "}
num_key = [str(x) for x in range(10)]  ### 数字键

move = lambda line, col=1: cout(f"\033[{line};{col}H")  # 绝对移动
cout = lambda *printed: print(*printed, end="", sep="")  # 改变默认参数的print
cline = lambda: (cout("\033[2K"))  # 清行
cls = lambda: (cout("\033[2J\033[H"))  # 清屏
hide_cursor = lambda: cout("\033[?25l")
show_cursor = lambda: cout("\033[?25h")
# 下面四个(相对坐标移动)好像都没用到，用的绝对坐标
up = lambda n: cout(f"\033[{n}A")
down = lambda n: cout(f"\033[{n}B")
right = lambda n: cout(f"\033[{Width * n}C")
left = lambda n: cout(f"\033[{Width * n}D")
# 判断当前shell(os.system用到的命令区别)
shell = os.environ.get('SHELL').strip().split()
if "powershell" in shell or "cmd" in shell:
    shell_mode = 1
else:
    shell_mode = 0


### 利用 ANSI 转义序列实现清屏移动光标等
def init_program():
    """
    初始化程序
    """
    hide_cursor()
    try:
        os.system("")  # ANSI 转义序列支持
    except Exception:
        print("Failed to enable ANSI")
        exit()

    colorama.init()


# getch实现无缓冲输入(win是c/c++同款，直接调用msvcrt动态链接库，类unix是ai写的)
def make_getch():
    """
    高阶函数封装判断平台过程
    """
    if os.name == "nt":  # Windows NT内核，其余基本都是类unix(posix)，除了ChromeOS之类的怪胎
        # os库里name的判定只有nt和posix两种(用的py3.9)
        from msvcrt import getch

        def win_get():
            return getch().decode()  # decode解码将byte对象转字符串

        return win_get
    else:
        import termios
        from tty import setraw
        from sys import stdin

        def unix_get():  # 看不懂思密达, generated by doubao
            fd = stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            try:
                setraw(stdin.fileno())
                ch = stdin.read(1)
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
            return ch

        return unix_get


getch = make_getch()


def print_all(Line, All):
    """
    只在开始运行打印一次，后面通过光标移动更改
    """
    global board_line
    cls()
    move(board_line)
    cout("  +" + "-" * (Line * Width + Width - 1), "+\n")
    for i in All[1:]:
        cout("  | ")
        for j in i[1:]:
            cout(" ", j, " ")
        cout(" |\n")
    cout("  +" + "-" * (Line * Width + Width - 1), "+")


def move_info(line: int, col: int) -> tuple:
    # ":*"和"->*"都是类型注释
    """
    将行列号转终端光标坐标
    """
    global board_line
    return line + board_line, col * Width


def generate_boom(All: list, num: int) -> list:
    """
    生成炸弹
    """
    from random import randint
    Line = get_line(All)
    if num > Line**2 // 3:
        num = Line**2 // 3  # 限制下炸弹数量
    rand_line = (lambda Line: (lambda: randint(1, Line)))(Line)
    # 高阶函数封装参数Line，配合lambda定义调用放一起实现可读性极差(笑)
    temp = set()
    while num > 0:
        pos = rand_line(), rand_line()
        if pos not in temp:
            temp.add(pos)
            num -= 1
    for i, j in list(temp):
        All[i][j] = element["Boom"]
    All[0] = True  # 用来标记是否成功生成炸弹
    return All


def get_line(All):
    """
    获取棋盘的边长
    """
    return len(All) - 1


def is_boom(pos, All):
    if All[pos[0]][pos[1]] == element["Boom"]:
        return True
    return False


def get_item(All, pos):
    return All[pos[0]][pos[1]]


def cal_count(Count, All):
    """
    计算每个位置炸弹数量
    """
    Line = get_line(All)
    for i in range(1, Line + 1):
        for j in range(1, Line + 1):
            all_edge = {(i - 1, j - 1), (i - 1, j), (i - 1, j + 1),
                        (i + 1, j - 1), (i + 1, j), (i + 1, j + 1), (i, j - 1),
                        (i, j + 1)}
            positions = [(r, c) for r, c in all_edge
                         if 1 <= r <= Line and 1 <= c <= Line]
            Count[i][j] = sum(1 for pos in positions if is_boom(pos, All))

    return Count


def show_line(line, Line):
    """
    显示相对行号
    """
    move(board_line + line)
    cout(BG, f"{abs(line):^2}", BB)
    for temp_line in range(1, Line + 1):
        if temp_line != line:
            move(board_line + temp_line, 1)
            relative = temp_line - line
            cout(f"{abs(relative):^2}")
        else:
            cout(BY)


def show_col(col, Line):
    """
    相对列号
    """
    _, term_col = move_info(1, col)  # 用不到的变量用下划线

    move(board_line - 1, term_col + 1)
    cout(colorama.Back.GREEN, f"{col:^3}", BB)
    for temp_col in range(1, Line + 1):
        if temp_col != col:
            _, term_col = move_info(1, temp_col)
            move(board_line - 1, term_col + 1)
            relative = temp_col - col
            cout(f"{abs(relative):^3}")
        else:
            cout(BY)


def show_relevant(line, col, Line, All):
    """
    显示相对行列号，高亮当前元素
    """
    show_line(line, Line)
    show_col(col, Line)
    shell_line, shell_col = move_info(line, col)
    move(shell_line, shell_col - 1)
    cout(BG, " ", All[line][col], " ", RES)


def click_item(line, col, Line, All, is_flaged, Count, is_revealed):
    """
    实现reveal动作, (click指原版扫雷点鼠标, 这里实际是摁键盘)
    """
    if is_flaged[line][col] or is_revealed[line][col]:
        return False, All, is_flaged, is_revealed
    if All[line][col] == element["Boom"]:
        is_revealed[line][col] = True
        return True, All, is_flaged, is_revealed

    def inner(l, c):
        """
        递归大法好，翻牌子
        """
        nonlocal All, is_flaged, is_revealed
        # nonlocal关键字调用父帧变量
        # 不加也可以调用，但是如果进行赋值操作会变成局部变量，不会影响父帧中同变量
        # global同理，不过调用的是全局帧的变量
        if l < 1 or l > Line or c < 1 or c > Line or is_revealed[l][c]:
            return

        if All[l][c] == element["Boom"]:
            return

        is_revealed[l][c] = True
        is_flaged[l][c] = False

        if Count[l][c] > 0:
            All[l][c] = str(Count[l][c])
            return
        else:  # 递归主体，其他为base case(基例/基线)
            All[l][c] = element["Flat"]
            for tl in [-1, 0, 1]:
                for tc in [-1, 0, 1]:
                    if tl == 0 and tc == 0:
                        continue
                    inner(l + tl, c + tc)

    inner(line, col)
    return False, All, is_flaged, is_revealed


def refresh_pos(pos, All, is_current=False):
    """
    重新打印某行，没用到，最终直接重新打印某个字符了
    """
    move(move_info(pos))
    left(1)
    if is_current:
        cout(BG)
    cout(" ", All[pos[0]][pos[1]], " ")
    if is_current:
        cout(RES)


def print_cursor(pos, All):
    """
    没用到，忘了写这玩意是干嘛的了，留着先，这个函数还没完成
    """
    move(move_info(*pos))
    left


def clear_bg(icon, pre_pos):
    """
    当前光标所在格子高亮，这个函数的作用是清除高亮效果(重打印嘛)
    """
    shell_line, shell_col = move_info(pre_pos[0], pre_pos[1])
    move(shell_line, shell_col - 1)
    cout(BG, " ", icon, " ", RES)


def print_message(Line, message, pre_pos, error=False):
    """
    打印信息，包括报错和按键
    """
    move(board_line + Line + (5 if error else 6))
    cline()
    cout(message)
    move(*pre_pos)


def clear_error(Line, pre_pos):
    """
    清除错误信息打印
    """
    move(board_line + Line + 6)
    cline()
    move(*pre_pos)


def get_key(Line, cursor_pos):
    """
    获取按键和数字键
    """
    current_key = None
    num_buffer = []
    is_ok = False
    while not is_ok:
        try:
            clear_error(Line, cursor_pos)
            if num_buffer:
                cline()
                print_message(Line, *num_buffer, cursor_pos)
            current_key = getch()
            if current_key in num_key:
                num_buffer.append(current_key)
            elif not any(current_key in keys for keys in key_binding.values()):
                print_message(Line, f"key {current_key} is invalid!",
                              cursor_pos, True)
            else:
                is_ok = True
        except Exception as e:
            print_message(Line, f"Error: {str(e)}", cursor_pos, True)
    num_buffer = [int(i) for i in num_buffer]  # getch().decode()是字符串
    if num_buffer == []:
        total = 1
    else:
        total = 0
        for i in num_buffer:
            total = total * 10 + i
    return total, current_key


def move_cursor_info(motion, cursor_pos, total, Line):
    if motion == "Up":
        return [
            1 if cursor_pos[0] - total < 1 else cursor_pos[0] - total,
            cursor_pos[1]
        ]
    elif motion == "Down":
        return [
            Line if cursor_pos[0] + total > Line else cursor_pos[0] + total,
            cursor_pos[1]
        ]
    elif motion == "Left":
        return [
            cursor_pos[0],
            1 if cursor_pos[1] - total < 1 else cursor_pos[1] - total
        ]
    elif motion == "Right":
        return [
            cursor_pos[0],
            Line if cursor_pos[1] + total > Line else cursor_pos[1] + total
        ]
    else:
        return cursor_pos


def run(Line=10,
        boom_count=None,
        All=None,
        is_flaged=None,
        is_reavealed=None,
        total_time=0):
    init_program()
    #判断是否给定数据，并生成缺失数据
    if not boom_count:
        boom_count = 2 * Line
    if not All:
        All = [[False]] + [[element["Unknow"] for _ in range(Line + 1)]
                           for _ in range(Line)]
        All = generate_boom(All, boom_count)
    else:
        Line = get_line(All)
    if not is_flaged:
        is_flaged = [[False] * (Line + 1) for _ in range(Line + 1)]
    if not is_revealed:
        is_revealed = [[False] * (Line + 1) for _ in range(Line + 1)]
    Count = [[0 for _ in range(Line + 1)] for _ in range(Line + 1)]
    #            #             #            #             #            #
    print_all(Line, All)
    cursor_pos = [Line // 2 if Line > 1 else 1, Line // 2 if Line > 1 else 1]
    show_relevant(*cursor_pos, Line, All)

    Count = cal_count(Count, All)
    # main loop 又臭又长
    while True:
        total, current_key = get_key(Line, cursor_pos)
        if current_key in key_binding["Other"]:
            print_message(Line, "", cursor_pos)
            if current_key == key_binding["Other"][0]:
                is_flaged[cursor_pos[0]][cursor_pos[1]] = not is_flaged[
                    cursor_pos[0]][cursor_pos[1]]
                if is_flaged[cursor_pos[0]][cursor_pos[1]]:
                    All[cursor_pos[0]][cursor_pos[1]] = element["Flag"]
                else:
                    All[cursor_pos[0]][cursor_pos[1]] = element["Unknow"]
                show_relevant(*cursor_pos, Line, All)
            else:
                is_boom_result, All, is_flaged, is_revealed = click_item(
                    cursor_pos[0], cursor_pos[1], Line, All, is_flaged, Count,
                    is_revealed)
                if is_boom_result:
                    print_message(Line, "BOOM! Game Over!", cursor_pos)
                    show_relevant(*cursor_pos, Line, All)
                    break
                show_relevant(*cursor_pos, Line, All)
        else:
            for direction, keys in key_binding.items():
                if current_key in keys:
                    motion = direction
                    break
            clear_bg(get_item(All, cursor_pos), cursor_pos)
            cursor_pos = move_cursor_info(motion, cursor_pos, total, Line)
            show_relevant(*cursor_pos, Line, All)

    #

    show_cursor()
    move(1)
    down(Line + board_line + 3)


def start():
    pass


Line = 10
All = [[False]] + [[element["Unknow"] for _ in range(Line + 1)]
                   for _ in range(Line)]
run()
